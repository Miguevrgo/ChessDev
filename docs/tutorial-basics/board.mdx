---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Board Representation

When developing a chess program, an internal board representation is crucial. It's not just for enforcing game rules during play, but also for enabling the search algorithm to simulate moves. There are various approaches we'll discuss, but for now, we'll preview one key point: simply using a matrix of pieces isn't enough.

We also have to account for some information about the game such as the side to move, castling and en passant rights, etc. There are also lots of different chess board implementations within the same techniques we are going to see. It is up to the programmer to design their own approach with the data considered to make it faster while maintaining reliability or ease of use.

We'll now discuss some of the board representations, going first through bitboards which are the recommended way that almost all computer chess engines follow. If you don't yet understand why it's better, you can try experimenting with your own approach — it may even be better! However, if you just want something really good out of the box, trust the way, and we'll see together why it's a good idea, even if it's not the most space-efficient approach.

## Pieces

There are various ways to represent the pieces. It also depends on the programming language used. We will not go too much in depth on whether one design is better than another, because there are lots of alternatives each with their own advantages.

One thing to consider: try to make piece representations branchless and space-efficient when possible. We want to access piece types quite frequently. Although it's not the main bottleneck, we don't recommend an OOP approach with an inherited class for each type of piece.

There are 6 different types of pieces for each side, so 12 in total. Since one piece only occupies one square at a time, a Nil-piece aka empty square can be useful. For cheaper design, most engines prefer encoding the piece type and color as separate variables. The most straightforward way is using an enumeration.

### Enumeration

Enumerating piece types is fine. We often order them from least valuable to most. Here's an example in C++ and Rust:

<Tabs>
<TabItem value="C++" label="C++">

```cpp showLineNumbers
enum PieceType {
    EMPTY, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
}

enum Color {
    WHITE = 0
    BLACK = 1
}

struct Piece {
    PieceType type;
    Color color;
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust showLineNumbers
#[derive(Copy, Clone, PartialEq, Eq)]
pub enum PieceType {
    None,
    Pawn,
    Knight,
    Bishop,
    Rook,
    Queen,
    King,
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub enum Color {
    White,
    Black,
}

#[derive(Copy, Clone)]
pub struct Piece {
    pub piece_type: PieceType,
    pub color: Color,
}
```

</TabItem>
</Tabs>

## Square

A square in chess refers to one of the 64 cells on a standard 8×8 board. Each square may be empty or occupied by a piece. In algebraic notation, squares are named using file (columns a to h) and rank (rows 1 to 8), such as e4 or a1.

Internally, it's common to number squares from 0 to 63. The most popular indexing scheme for bitboards is Little-Endian Rank-File (LERF) mapping, where:

- Square a1 is index 0 (LSB)
- Square h1 is index 7
- Square a2 is index 8
- ...
- Square h8 is index 63 (MSB)

This order matches how a 64-bit integer maps directly to the board, from least significant bit (LSB) to most significant bit (MSB), left to right, bottom to top.

A good reference to visualize this mapping: [Bitboard Viewer](https://tearth.dev/bitboard-viewer/)

## Board

### Bitboards

Bitboards are the standard and recommended way of representing a chess board in modern engines. While not the most space-efficient, they enable extremely fast operations using bitwise logic.
A bitboard is simply a 64-bit integer (`u64` in Rust, `uint64_t` in C++), where each bit corresponds to a square on the board. A bit set to 1 means the square is occupied; 0 means it's empty.

A natural question arises:
- **How do we know which piece is on each square if a bitboard only tells us if a square is occupied?**

There are multiple strategies:
- **[8 Bitboards]** One effective and compact approach is to use 8 bitboards in total:
    - 6 bitboards for each piece type (regardless of color):
    - 2 bitboards for side occupancy:

    With this setup, you can derive the full board state. For example, to get the bitboard of white pawns: `bitboards[pawn] | bitboards[white]`
    This design is compact and performant. It avoids redundant storage while still allowing fast queries, however, it is not the only possible
    approach:

- **[12 Bitboards]** One bitboard for each piece type and color, additionaly, some engines decide to use another 
  two bitboards for side occupancy.

- **[Hybrid approach]** Where we use the bitboards for fast operations + array of pieces for easier access for some operations, this involves
  a bigger size in the end, however, it can prove useful for many of the methods.

Let’s now see how we can implement a basic BitBoard in Rust. We'll define the most common bitboard operations and provide utility methods that are frequently used in chess engines. While there are many valid design choices, the implementation shown below balances clarity, efficiency, and usability.
**Key Operations:**
- Get bit: Check whether a square is set.
- Set bit: Mark a square as occupied.
- Pop bit: Clear a bit (e.g., when a piece moves).
- Count bits: Count how many squares are set (e.g., for population count or mobility).
- LSB: Find the least significant bit set (used for iterating over pieces).

We’ll also define a debug-friendly Display implementation for visualizing the bitboard.
<Tabs>
<TabItem value="C++" label="C++">

```cpp showLineNumbers
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust showLineNumbers
struct BitBoard(u64);

impl BitBoard {
    pub fn get_bit(self, square: Square) -> bool {
        self.0 & (1u64 << square.index()) != 0
    }

    pub fn set_bit(self, square: Square) -> Self {
        Self(self.0 | (1u64 << square.index()))
    }

    pub fn pop_bit(self, square: Square) -> Self {
        Self(self.0 & !(1u64 << square.index()))
    }

    pub fn count_bits(self) -> u32 {
        self.0.count_ones()
    }

    pub fn lsb(self) -> Square {
        Square::new(self.0.trailing_zeros() as usize)
    }
}

/// Optional method which can be useful when debugging
impl std::fmt::Display for BitBoard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "  a b c d e f g h")?;
        writeln!(f, " ┌────────────────┐")?;
        for rank in (0..8).rev() {
            write!(f, "{}│", rank + 1)?;
            for file in 0..8 {
                let index = rank * 8 + file;
                let bit = (self.0 >> index) & 1;
                write!(f, "{} ", if bit == 1 { "1" } else { "0" })?;
            }
            writeln!(f, "│")?;
        }
        writeln!(f, " └────────────────┘")
    }
}
```

</TabItem>
</Tabs>

**Notes**:
- Square is assumed to be a struct or enum with a method index() -> usize returning its 0–63 index.
- You can also implement your own version of count_ones (popcount) using techniques like the HAKMEM algorithm or lookup tables, though the built-in version is already highly optimized in modern CPUs.
- Advanced methods like pop_lsb() (clear and return index) and iteration over bits can also be added as needed.
