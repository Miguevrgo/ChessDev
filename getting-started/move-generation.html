<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move Generation - ChessDev</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Getting Started</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/board-representation.html"><strong aria-hidden="true">2.1.</strong> Board Representation</a></li><li class="chapter-item expanded "><a href="../getting-started/move-generation.html" class="active"><strong aria-hidden="true">2.2.</strong> Move Generation</a></li><li class="chapter-item expanded "><a href="../getting-started/testing-and-finishing.html"><strong aria-hidden="true">2.3.</strong> Testing and Finishing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ChessDev</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="move-generation"><a class="header" href="#move-generation">Move Generation</a></h1>
<p>If you have completed and read the Board tutorial, you should have a basic understanding of how to represent a chess board and pieces in code. Now, we will implement the move generation logic for our engine.
There are many different ways to implement move generation, here, we will discuss many and so it is up to you to choose the one that fits your needs best or you understand best.</p>
<p>This implementation heavily depends on the board representation, as it is quite the standard to use bitboards, we will assume you are using them as well, however, if you are not, I hope you can still follow along and adapt the code to your needs.
Either way, move generation is the part of the board implementation which is going to take the most time while searching, coding, and debugging, so it is important to get it right. We will later discuss how to check whether or not
your engine is generating the correct moves, however, if you follow the code examples and the explanations, you should be able to implement a working move generation logic.</p>
<h2 id="legality"><a class="header" href="#legality">Legality</a></h2>
<p>There are two main approaches to move generation: generating all legal moves and generating pseudo-legal moves for later check.</p>
<h3 id="pseudo-legal-moves"><a class="header" href="#pseudo-legal-moves">Pseudo-legal moves</a></h3>
<p>In pseudo-legal move generation, we generate all moves which are possible according to the movement rules of each piece,
without checking whether or not the move would leave the king in check. This is the most common approach and is usually faster
than generating legal moves, as it does not require checking for checks after each move.</p>
<h3 id="legal-moves"><a class="header" href="#legal-moves">Legal moves</a></h3>
<p>In legal move generation, we generate only moves which do not leave the king in check.
This is usually slower than generating pseudo-legal moves, as it requires checking for checks after each move.</p>
<p>Either way, pins, en passant and castling will be the hardests parts to get right.</p>
<h2 id="standard-moves"><a class="header" href="#standard-moves">Standard moves</a></h2>
<p>Standard moves don’t require much explanation or advanced techniques. The real challenge lies in the special moves mentioned earlier and optimizing sliding piece attack generation.</p>
<p>We’ll focus this section on those special and performance-critical moves, but first, let’s implement the basic move representation.
We need a way to store information about each move. While some engines store additional data to assist in move sorting or other heuristics, we'll stick to what is strictly necessary:</p>
<p>We need to store:</p>
<ul>
<li>Origin square (2^6 = 64 positions so we will need 6 bits)</li>
<li>Destination square (2^6 = 64 positions so we will need 6 bits)</li>
<li>Type of Move</li>
</ul>
<p>For the move type, we will use 4 bits:</p>
<ul>
<li>2 bits to describe the kind of move (quiet, capture, castling, etc.)</li>
<li>2 additional bits for promotions (Queen, Knight, Rook, Bishop)</li>
</ul>
<p>We could have used a 3-bit encoding for all 8 special cases (castling, en passant, 4 promotion types),
but since the compiler will likely align the Move struct to 16 bits anyway, this bit allocation makes it
easier to distinguish between move categories quickly.</p>
<p>Let's now implement the Move struct:</p>
<h4 id="c"><a class="header" href="#c">C++</a></h4>
<pre><code class="language-cpp">#TODO:
</code></pre>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug, Hash)]
pub enum MoveKind {
    Quiet = 0b0000,
    Castle = 0b0001,
    DoublePush = 0b0010,

    // Promotions have 3rd bit set
    KnightPromotion = 0b0100,
    BishopPromotion = 0b0101,
    RookPromotion = 0b0110,
    QueenPromotion = 0b0111,

    // Captures have 4th bit set
    Capture = 0b1000,
    EnPassant = 0b1001,

    KnightCapPromo = 0b1100,
    BishopCapPromo = 0b1101,
    RookCapPromo = 0b1110,
    QueenCapPromo = 0b1111,
}

pub struct Move(pub u16);

impl Move {
    pub fn new(src: Square, dest: Square, kind: MoveKind) -&gt; Self {
        Self((src.index() as u16) | ((dest.index() as u16) &lt;&lt; 6) | ((kind as u16) &lt;&lt; 12))
    }

    pub fn get_source(self) -&gt; Square {
        Square::new((self.0 &amp; SRC) as usize)
    }

    pub fn get_dest(self) -&gt; Square {
        Square::new(((self.0 &amp; DST) &gt;&gt; 6) as usize)
    }

    pub fn get_type(self) -&gt; MoveKind {
        match (self.0 &amp; TYPE) &gt;&gt; 12 {
            0b0000 =&gt; MoveKind::Quiet,
            0b0001 =&gt; MoveKind::Castle,
            0b0010 =&gt; MoveKind::DoublePush,
            0b1000 =&gt; MoveKind::Capture,
            0b1001 =&gt; MoveKind::EnPassant,

            0b0100 =&gt; MoveKind::KnightPromotion,
            0b0101 =&gt; MoveKind::BishopPromotion,
            0b0110 =&gt; MoveKind::RookPromotion,
            0b0111 =&gt; MoveKind::QueenPromotion,

            0b1100 =&gt; MoveKind::KnightCapPromo,
            0b1101 =&gt; MoveKind::BishopCapPromo,
            0b1110 =&gt; MoveKind::RookCapPromo,
            0b1111 =&gt; MoveKind::QueenCapPromo,

            _ =&gt; unreachable!(),
        }
    }
}

impl std::fmt::Display for Move {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        let s = format!("{}{}", self.get_source(), self.get_dest());
        let move_type = self.get_type();

        if move_type.is_promotion() {
            write!(
                f,
                "{}{}",
                s,
                move_type.get_promotion(Colour::Black).to_char()
            )
        } else {
            write!(f, "{s}")
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, we have also defined a MoveKind struct to represent the 4 bits which we are using for move type,
the order provided before allows us to get the information we need by simply shifting the Move some positions.
There is also an unnecessary display implementation which comes very handy when debugging. Now that we have succesfully implemented
a struct for our moves, we are going to generate them, this time, we will go back to where we defined the board and lets
see how we can generate the easier moves, as we said, we are firstly going to generate all the possible moves and then we will filter
the ones which are completely legal, lets implement in a board method (lets call it pseudo_gen for example) the moves for all types
of pieces, of course, we are just generating for the current color pieces so the first thing will be getting the side.</p>
<h4 id="pawns"><a class="header" href="#pawns">Pawns</a></h4>
<p>As we know, pawns are able to go forward 1 square (2 if they are in starting position) and to capture one square to their front diagonals,
additionally, they have the en passant rule, which as we said, allows us to move diagonally even though we have a pawn on our side if that
pawn moved two squares forward the last turn.</p>
<p>To get all pawn movements, we will first have to identify where all paws are, then, we will iterate each one pushing its possible moves to a
handy structure, you can use an array, a vector or whatever you consider best, however, a vector seems the most reasonable:</p>
<h4 id="c-1"><a class="header" href="#c-1">C++</a></h4>
<pre><code class="language-cpp">// auto Board::generate_pseudo_moves(Colour side) -&gt; std::vector&lt;Move&gt;
std::size_t side_idx = side as usize;
BitBoard pawn_bb = pieces[Piece::WP.index()] &amp; self.sides[side_idx];

// Now we iterate over all pawns
//TODO
</code></pre>
<h4 id="rust-1"><a class="header" href="#rust-1">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// fn generate_pseudo_moves(&amp;self, side: Colour) -&gt; Vec&lt;Move&gt;
    let mut moves = Vec::with_capacity(64);
    let side_idx = side as usize;

    // Now we iterate over all pawns
    let mut pawn_bb = self.pieces[Piece::WP.index()] &amp; self.sides[side_idx];
    while pawn_bb != BitBoard::EMPTY {
        let src = pawn_bb.lsb(); // Least significant Byte
        moves.extend(all_pawn_moves(
            src,
            if side == Colour::White {
                Piece::WP
            } else {
                Piece::BP
            },
            self,
        )); // Pushing each possible move for the current pawn
        pawn_bb = pawn_bb.pop_bit(src);
    }

/// pub fn all_pawn_moves(src: Square, piece: Piece, board: &amp;Board) -&gt; Vec&lt;Move&gt;
    let mut moves = Vec::new();
    let forward = piece.colour().forward(); // +1 | -1 Depending on color

    let start_rank = BitBoard::START_RANKS[piece.colour() as usize]; // Starting rank bitboard (1s in 2|7 row)
    let promo_rank = BitBoard::PROMO_RANKS[piece.colour() as usize]; // Promotion rank bitboard
    let opponent = board.sides[!piece.colour() as usize];

    // If our move dest is promo rank, we are pushing all kinds of promotions
    if let Some(dest) = src.jump(0, forward) {
        if promo_rank.get_bit(dest) {
            moves.push(Move::new(src, dest, MoveKind::QueenPromotion));
            moves.push(Move::new(src, dest, MoveKind::RookPromotion));
            moves.push(Move::new(src, dest, MoveKind::BishopPromotion));
            moves.push(Move::new(src, dest, MoveKind::KnightPromotion));
        } else {
            // If it is not a promotion, it is not either a capture so quiet move
            moves.push(Move::new(src, dest, MoveKind::Quiet));
        }
    }

    // Starting row is able to advance two squares
    if start_rank.get_bit(src) {
        moves.push(Move::new(
            src,
            src.jump(0, 2 * forward).unwrap(),
            MoveKind::DoublePush,
        ));
    }

    // Diagonal checking (capture)
    for delta in [(-1, forward), (1, forward)] {
        if let Some(dest) = src.jump(delta.0, delta.1) {
            if opponent.get_bit(dest) {
                if promo_rank.get_bit(dest) { // A capture + Promotion is possible
                    moves.push(Move::new(src, dest, MoveKind::QueenCapPromo));
                    moves.push(Move::new(src, dest, MoveKind::RookCapPromo));
                    moves.push(Move::new(src, dest, MoveKind::BishopCapPromo));
                    moves.push(Move::new(src, dest, MoveKind::KnightCapPromo));
                } else {
                    moves.push(Move::new(src, dest, MoveKind::Capture));
                }
            } else if board.en_passant == Some(dest) { // If an en_passant can be made in the diagonal
                let ep_target = dest.jump(0, -forward).expect("Invalid en passant target");
                if opponent.get_bit(ep_target) {
                    moves.push(Move::new(src, dest, MoveKind::EnPassant));
                }
            }
        }
    }
    moves
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see the code is quite boiler plate, however, if you read it you will see its just the modularity of generating the pseudo moves all together for each piece (for now there is only the pawn) and pushing them to the structure of choice so that we can use them later. For the pawn generation, its just the promotions (which we have to generate all possible ones even though in the search we will usually just promote to queen), the simple and quiet pawn push, the double push if the pawn is in the starting rank and the diagonally captures (which also have to include promotions if the rank is promotion) and en passant respectively. We generate all possible pawn moves based on the position of pieces and then in the caller we filter the ones which are really valid. For the en passant move, we are storing on the board every time a double move is made, the square where it can be done. Let's now extend the pseudo move generation for the knight and king moves, which are the last ones which do not require sliding logic:</p>
<h3 id="king"><a class="header" href="#king">King</a></h3>
<p>King's Movement is really simple, despite the Castling logic, which is quite tricky, we just have to add the in-board moves for all 8 possible positions surrounding the
king, as we are pseudo generating yet, we will push both Capture and Quiet Move to the vector, as we have said, this can be changed so that every pushed move is already valid, or at least is pseudo valid and just has to check whether it leaves the king on check or not. After this, you can leave the method with the first part for now but I will also explain the Castling logic for anyone interested in doing it now:</p>
<h4 id="c-2"><a class="header" href="#c-2">C++</a></h4>
<pre><code class="language-cpp">#TODO
</code></pre>
<h4 id="rust-2"><a class="header" href="#rust-2">Rust</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn all_king_moves(src: Square) -&gt; Vec&lt;Move&gt; {
    let mut moves = Vec::with_capacity(4); // Conservative approach (2,4,8) are fine
    // KING_OFFSETS its just [0,1],[1,1],[1,0],[1,-1], etc
    for &amp;(file_delta, rank_delta) in &amp;KING_OFFSETS {
        if let Some(dest) = src.jump(file_delta, rank_delta) {
            moves.push(Move::new(src, dest, MoveKind::Quiet));
            moves.push(Move::new(src, dest, MoveKind::Capture));
        }
    }

    // Now for the Castling logic
    if src.to_board() &amp; BitBoard::KING_START_POS != BitBoard::EMPTY {
        moves.push(Move::new(
            src,
            Square::from_row_col(src.row(), 6),
            MoveKind::Castle,
        ));
        moves.push(Move::new(
            src,
            Square::from_row_col(src.row(), 2),
            MoveKind::Castle,
        ));
    }

    moves
}

<span class="boring">}</span></code></pre></pre>
<h3 id="castling"><a class="header" href="#castling">Castling</a></h3>
<p>We have already said that any board representation needed a way to store the current castling state, this means knowing which color can castle and if it is able for both, none or one side. The CastlingRights struct has already been presented, yet, it may not be very clear how we are interacting with it, for the most part, the make_move method will be handling updating the state of the Castling rights so for now we just have to use them:</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-started/board-representation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../getting-started/testing-and-finishing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-started/board-representation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../getting-started/testing-and-finishing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
